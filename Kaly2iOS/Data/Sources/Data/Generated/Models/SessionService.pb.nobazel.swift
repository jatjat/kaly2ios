// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Kaly2iOS/Shared/logic/Infrastructure/Impl/Protos/SessionService.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Ca_Joelathiessen_Kaly2_Proto_SubscribeNewRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var robotID: Int64 = 0

  var mapID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ca_Joelathiessen_Kaly2_Proto_SubscribeExistingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var robotSessionID: Int64 = 0

  var minPrevIterationNo: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ca_Joelathiessen_Kaly2_Proto_SubscribeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var robotSessionID: Int64 = 0

  var iteration: Ca_Joelathiessen_Kaly2_Proto_Iteration {
    get {return _iteration ?? Ca_Joelathiessen_Kaly2_Proto_Iteration()}
    set {_iteration = newValue}
  }
  /// Returns true if `iteration` has been explicitly set.
  var hasIteration: Bool {return self._iteration != nil}
  /// Clears the value of `iteration`. Subsequent reads from it will return its default value.
  mutating func clearIteration() {self._iteration = nil}

  var retryServer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _iteration: Ca_Joelathiessen_Kaly2_Proto_Iteration? = nil
}

struct Ca_Joelathiessen_Kaly2_Proto_Iteration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var iterationNo: Int64 {
    get {return _storage._iterationNo}
    set {_uniqueStorage()._iterationNo = newValue}
  }

  var timestamp: Int64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  var bestPose: Ca_Joelathiessen_Kaly2_Proto_Pose {
    get {return _storage._bestPose ?? Ca_Joelathiessen_Kaly2_Proto_Pose()}
    set {_uniqueStorage()._bestPose = newValue}
  }
  /// Returns true if `bestPose` has been explicitly set.
  var hasBestPose: Bool {return _storage._bestPose != nil}
  /// Clears the value of `bestPose`. Subsequent reads from it will return its default value.
  mutating func clearBestPose() {_uniqueStorage()._bestPose = nil}

  var odoPose: Ca_Joelathiessen_Kaly2_Proto_Pose {
    get {return _storage._odoPose ?? Ca_Joelathiessen_Kaly2_Proto_Pose()}
    set {_uniqueStorage()._odoPose = newValue}
  }
  /// Returns true if `odoPose` has been explicitly set.
  var hasOdoPose: Bool {return _storage._odoPose != nil}
  /// Clears the value of `odoPose`. Subsequent reads from it will return its default value.
  mutating func clearOdoPose() {_uniqueStorage()._odoPose = nil}

  var truePose: Ca_Joelathiessen_Kaly2_Proto_Pose {
    get {return _storage._truePose ?? Ca_Joelathiessen_Kaly2_Proto_Pose()}
    set {_uniqueStorage()._truePose = newValue}
  }
  /// Returns true if `truePose` has been explicitly set.
  var hasTruePose: Bool {return _storage._truePose != nil}
  /// Clears the value of `truePose`. Subsequent reads from it will return its default value.
  mutating func clearTruePose() {_uniqueStorage()._truePose = nil}

  var features: [Ca_Joelathiessen_Kaly2_Proto_Feature] {
    get {return _storage._features}
    set {_uniqueStorage()._features = newValue}
  }

  var particles: [Ca_Joelathiessen_Kaly2_Proto_Particle] {
    get {return _storage._particles}
    set {_uniqueStorage()._particles = newValue}
  }

  var slamSettings: Ca_Joelathiessen_Kaly2_Proto_SlamSettings {
    get {return _storage._slamSettings ?? Ca_Joelathiessen_Kaly2_Proto_SlamSettings()}
    set {_uniqueStorage()._slamSettings = newValue}
  }
  /// Returns true if `slamSettings` has been explicitly set.
  var hasSlamSettings: Bool {return _storage._slamSettings != nil}
  /// Clears the value of `slamSettings`. Subsequent reads from it will return its default value.
  mutating func clearSlamSettings() {_uniqueStorage()._slamSettings = nil}

  var sessionSettings: Ca_Joelathiessen_Kaly2_Proto_SessionSettings {
    get {return _storage._sessionSettings ?? Ca_Joelathiessen_Kaly2_Proto_SessionSettings()}
    set {_uniqueStorage()._sessionSettings = newValue}
  }
  /// Returns true if `sessionSettings` has been explicitly set.
  var hasSessionSettings: Bool {return _storage._sessionSettings != nil}
  /// Clears the value of `sessionSettings`. Subsequent reads from it will return its default value.
  mutating func clearSessionSettings() {_uniqueStorage()._sessionSettings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ca_Joelathiessen_Kaly2_Proto_Pose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Float = 0

  var y: Float = 0

  var heading: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ca_Joelathiessen_Kaly2_Proto_SlamSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numParticles: Int32 = 0

  var sensorDistVar: Float = 0

  var sensorAngVar: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ca_Joelathiessen_Kaly2_Proto_SessionSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isRunning: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ca_Joelathiessen_Kaly2_Proto_Feature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Float = 0

  var y: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ca_Joelathiessen_Kaly2_Proto_Particle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Float = 0

  var y: Float = 0

  var heading: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ca_Joelathiessen_Kaly2_Proto_GetPastIterationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var robotSessionID: Int64 = 0

  var firstIterationNo: Int64 = 0

  var uptoIterationNo: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ca_Joelathiessen_Kaly2_Proto_GetPastIterationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var robotSessionID: Int64 = 0

  var iterations: [Ca_Joelathiessen_Kaly2_Proto_Iteration] = []

  var retryServer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ca_Joelathiessen_Kaly2_Proto_ModifySessionSettingsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var robotSessionID: Int64 = 0

  var shouldRun: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ca_Joelathiessen_Kaly2_Proto_ModifySessionSettingsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var retryServer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ca_Joelathiessen_Kaly2_Proto_ModifySlamSettingsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var robotSessionID: Int64 = 0

  var numParticles: Int32 = 0

  var sensorDistVar: Float = 0

  var sensorAngVar: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ca_Joelathiessen_Kaly2_Proto_ModifySlamSettingsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var retryServer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ca.joelathiessen.kaly2.proto"

extension Ca_Joelathiessen_Kaly2_Proto_SubscribeNewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeNewRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "robotId"),
    2: .same(proto: "mapId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.robotID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.mapID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.robotID != 0 {
      try visitor.visitSingularInt64Field(value: self.robotID, fieldNumber: 1)
    }
    if self.mapID != 0 {
      try visitor.visitSingularInt64Field(value: self.mapID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_SubscribeNewRequest, rhs: Ca_Joelathiessen_Kaly2_Proto_SubscribeNewRequest) -> Bool {
    if lhs.robotID != rhs.robotID {return false}
    if lhs.mapID != rhs.mapID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ca_Joelathiessen_Kaly2_Proto_SubscribeExistingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeExistingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "robotSessionId"),
    3: .same(proto: "minPrevIterationNo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.robotSessionID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.minPrevIterationNo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.robotSessionID != 0 {
      try visitor.visitSingularInt64Field(value: self.robotSessionID, fieldNumber: 1)
    }
    if self.minPrevIterationNo != 0 {
      try visitor.visitSingularInt64Field(value: self.minPrevIterationNo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_SubscribeExistingRequest, rhs: Ca_Joelathiessen_Kaly2_Proto_SubscribeExistingRequest) -> Bool {
    if lhs.robotSessionID != rhs.robotSessionID {return false}
    if lhs.minPrevIterationNo != rhs.minPrevIterationNo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ca_Joelathiessen_Kaly2_Proto_SubscribeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "robotSessionId"),
    2: .same(proto: "iteration"),
    3: .same(proto: "retryServer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.robotSessionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._iteration) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.retryServer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.robotSessionID != 0 {
      try visitor.visitSingularInt64Field(value: self.robotSessionID, fieldNumber: 1)
    }
    try { if let v = self._iteration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.retryServer.isEmpty {
      try visitor.visitSingularStringField(value: self.retryServer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_SubscribeResponse, rhs: Ca_Joelathiessen_Kaly2_Proto_SubscribeResponse) -> Bool {
    if lhs.robotSessionID != rhs.robotSessionID {return false}
    if lhs._iteration != rhs._iteration {return false}
    if lhs.retryServer != rhs.retryServer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ca_Joelathiessen_Kaly2_Proto_Iteration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Iteration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "iterationNo"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "bestPose"),
    4: .same(proto: "odoPose"),
    5: .same(proto: "truePose"),
    6: .same(proto: "features"),
    7: .same(proto: "particles"),
    8: .same(proto: "slamSettings"),
    9: .same(proto: "sessionSettings"),
  ]

  fileprivate class _StorageClass {
    var _iterationNo: Int64 = 0
    var _timestamp: Int64 = 0
    var _bestPose: Ca_Joelathiessen_Kaly2_Proto_Pose? = nil
    var _odoPose: Ca_Joelathiessen_Kaly2_Proto_Pose? = nil
    var _truePose: Ca_Joelathiessen_Kaly2_Proto_Pose? = nil
    var _features: [Ca_Joelathiessen_Kaly2_Proto_Feature] = []
    var _particles: [Ca_Joelathiessen_Kaly2_Proto_Particle] = []
    var _slamSettings: Ca_Joelathiessen_Kaly2_Proto_SlamSettings? = nil
    var _sessionSettings: Ca_Joelathiessen_Kaly2_Proto_SessionSettings? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _iterationNo = source._iterationNo
      _timestamp = source._timestamp
      _bestPose = source._bestPose
      _odoPose = source._odoPose
      _truePose = source._truePose
      _features = source._features
      _particles = source._particles
      _slamSettings = source._slamSettings
      _sessionSettings = source._sessionSettings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._iterationNo) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._timestamp) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._bestPose) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._odoPose) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._truePose) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._features) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._particles) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._slamSettings) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._sessionSettings) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._iterationNo != 0 {
        try visitor.visitSingularInt64Field(value: _storage._iterationNo, fieldNumber: 1)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestamp, fieldNumber: 2)
      }
      try { if let v = _storage._bestPose {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._odoPose {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._truePose {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._features.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._features, fieldNumber: 6)
      }
      if !_storage._particles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._particles, fieldNumber: 7)
      }
      try { if let v = _storage._slamSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._sessionSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_Iteration, rhs: Ca_Joelathiessen_Kaly2_Proto_Iteration) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._iterationNo != rhs_storage._iterationNo {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._bestPose != rhs_storage._bestPose {return false}
        if _storage._odoPose != rhs_storage._odoPose {return false}
        if _storage._truePose != rhs_storage._truePose {return false}
        if _storage._features != rhs_storage._features {return false}
        if _storage._particles != rhs_storage._particles {return false}
        if _storage._slamSettings != rhs_storage._slamSettings {return false}
        if _storage._sessionSettings != rhs_storage._sessionSettings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ca_Joelathiessen_Kaly2_Proto_Pose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pose"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "heading"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.heading) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.heading != 0 {
      try visitor.visitSingularFloatField(value: self.heading, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_Pose, rhs: Ca_Joelathiessen_Kaly2_Proto_Pose) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.heading != rhs.heading {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ca_Joelathiessen_Kaly2_Proto_SlamSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlamSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numParticles"),
    2: .same(proto: "sensorDistVar"),
    3: .same(proto: "sensorAngVar"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.numParticles) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.sensorDistVar) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.sensorAngVar) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numParticles != 0 {
      try visitor.visitSingularInt32Field(value: self.numParticles, fieldNumber: 1)
    }
    if self.sensorDistVar != 0 {
      try visitor.visitSingularFloatField(value: self.sensorDistVar, fieldNumber: 2)
    }
    if self.sensorAngVar != 0 {
      try visitor.visitSingularFloatField(value: self.sensorAngVar, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_SlamSettings, rhs: Ca_Joelathiessen_Kaly2_Proto_SlamSettings) -> Bool {
    if lhs.numParticles != rhs.numParticles {return false}
    if lhs.sensorDistVar != rhs.sensorDistVar {return false}
    if lhs.sensorAngVar != rhs.sensorAngVar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ca_Joelathiessen_Kaly2_Proto_SessionSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isRunning"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isRunning) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isRunning != false {
      try visitor.visitSingularBoolField(value: self.isRunning, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_SessionSettings, rhs: Ca_Joelathiessen_Kaly2_Proto_SessionSettings) -> Bool {
    if lhs.isRunning != rhs.isRunning {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ca_Joelathiessen_Kaly2_Proto_Feature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Feature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_Feature, rhs: Ca_Joelathiessen_Kaly2_Proto_Feature) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ca_Joelathiessen_Kaly2_Proto_Particle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Particle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "heading"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.heading) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.heading != 0 {
      try visitor.visitSingularFloatField(value: self.heading, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_Particle, rhs: Ca_Joelathiessen_Kaly2_Proto_Particle) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.heading != rhs.heading {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ca_Joelathiessen_Kaly2_Proto_GetPastIterationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPastIterationsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "robotSessionId"),
    2: .same(proto: "firstIterationNo"),
    3: .same(proto: "uptoIterationNo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.robotSessionID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.firstIterationNo) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.uptoIterationNo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.robotSessionID != 0 {
      try visitor.visitSingularInt64Field(value: self.robotSessionID, fieldNumber: 1)
    }
    if self.firstIterationNo != 0 {
      try visitor.visitSingularInt64Field(value: self.firstIterationNo, fieldNumber: 2)
    }
    if self.uptoIterationNo != 0 {
      try visitor.visitSingularInt64Field(value: self.uptoIterationNo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_GetPastIterationsRequest, rhs: Ca_Joelathiessen_Kaly2_Proto_GetPastIterationsRequest) -> Bool {
    if lhs.robotSessionID != rhs.robotSessionID {return false}
    if lhs.firstIterationNo != rhs.firstIterationNo {return false}
    if lhs.uptoIterationNo != rhs.uptoIterationNo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ca_Joelathiessen_Kaly2_Proto_GetPastIterationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPastIterationsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "robotSessionId"),
    2: .same(proto: "iterations"),
    3: .same(proto: "retryServer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.robotSessionID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.iterations) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.retryServer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.robotSessionID != 0 {
      try visitor.visitSingularInt64Field(value: self.robotSessionID, fieldNumber: 1)
    }
    if !self.iterations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.iterations, fieldNumber: 2)
    }
    if !self.retryServer.isEmpty {
      try visitor.visitSingularStringField(value: self.retryServer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_GetPastIterationsResponse, rhs: Ca_Joelathiessen_Kaly2_Proto_GetPastIterationsResponse) -> Bool {
    if lhs.robotSessionID != rhs.robotSessionID {return false}
    if lhs.iterations != rhs.iterations {return false}
    if lhs.retryServer != rhs.retryServer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ca_Joelathiessen_Kaly2_Proto_ModifySessionSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModifySessionSettingsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "robotSessionId"),
    2: .same(proto: "shouldRun"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.robotSessionID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.shouldRun) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.robotSessionID != 0 {
      try visitor.visitSingularInt64Field(value: self.robotSessionID, fieldNumber: 1)
    }
    if self.shouldRun != false {
      try visitor.visitSingularBoolField(value: self.shouldRun, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_ModifySessionSettingsRequest, rhs: Ca_Joelathiessen_Kaly2_Proto_ModifySessionSettingsRequest) -> Bool {
    if lhs.robotSessionID != rhs.robotSessionID {return false}
    if lhs.shouldRun != rhs.shouldRun {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ca_Joelathiessen_Kaly2_Proto_ModifySessionSettingsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModifySessionSettingsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "retryServer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.retryServer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.retryServer.isEmpty {
      try visitor.visitSingularStringField(value: self.retryServer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_ModifySessionSettingsResponse, rhs: Ca_Joelathiessen_Kaly2_Proto_ModifySessionSettingsResponse) -> Bool {
    if lhs.retryServer != rhs.retryServer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ca_Joelathiessen_Kaly2_Proto_ModifySlamSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModifySlamSettingsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "robotSessionId"),
    2: .same(proto: "numParticles"),
    3: .same(proto: "sensorDistVar"),
    4: .same(proto: "sensorAngVar"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.robotSessionID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.numParticles) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.sensorDistVar) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.sensorAngVar) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.robotSessionID != 0 {
      try visitor.visitSingularInt64Field(value: self.robotSessionID, fieldNumber: 1)
    }
    if self.numParticles != 0 {
      try visitor.visitSingularInt32Field(value: self.numParticles, fieldNumber: 2)
    }
    if self.sensorDistVar != 0 {
      try visitor.visitSingularFloatField(value: self.sensorDistVar, fieldNumber: 3)
    }
    if self.sensorAngVar != 0 {
      try visitor.visitSingularFloatField(value: self.sensorAngVar, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_ModifySlamSettingsRequest, rhs: Ca_Joelathiessen_Kaly2_Proto_ModifySlamSettingsRequest) -> Bool {
    if lhs.robotSessionID != rhs.robotSessionID {return false}
    if lhs.numParticles != rhs.numParticles {return false}
    if lhs.sensorDistVar != rhs.sensorDistVar {return false}
    if lhs.sensorAngVar != rhs.sensorAngVar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ca_Joelathiessen_Kaly2_Proto_ModifySlamSettingsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModifySlamSettingsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "retryServer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.retryServer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.retryServer.isEmpty {
      try visitor.visitSingularStringField(value: self.retryServer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ca_Joelathiessen_Kaly2_Proto_ModifySlamSettingsResponse, rhs: Ca_Joelathiessen_Kaly2_Proto_ModifySlamSettingsResponse) -> Bool {
    if lhs.retryServer != rhs.retryServer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
